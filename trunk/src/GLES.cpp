/*
 * Copyright (c) 2011, okazoh_tk. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  - Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  - Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  - Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "GLES.h"

namespace crateris {

#define NO_IMPL()

GLES::GLES()
{
}

GLES::~GLES()
{
}

void GLES::AlphaFunc(
    GLenum func,
    GLclampf ref)
{
    NO_IMPL();
}

void GLES::ClearColor(
    GLclampf red,
    GLclampf green,
    GLclampf blue,
    GLclampf alpha)
{
    NO_IMPL();
}

void GLES::ClearDepthf(GLclampf depth)
{
    NO_IMPL();
}

void GLES::ClipPlanef(
    GLenum plane,
    const GLfloat *equation)
{
    NO_IMPL();
}

void GLES::Color4f(
    GLfloat red,
    GLfloat green,
    GLfloat blue,
    GLfloat alpha)
{
    NO_IMPL();
}

void GLES::DepthRangef(
    GLclampf zNear,
    GLclampf zFar)
{
    NO_IMPL();
}

void GLES::Fogf(
    GLenum pname,
    GLfloat param)
{
    NO_IMPL();
}

void GLES::Fogfv(
    GLenum pname,
    const GLfloat *params)
{
    NO_IMPL();
}

void GLES::Frustumf(
    GLfloat left,
    GLfloat right,
    GLfloat bottom,
    GLfloat top,
    GLfloat zNear,
    GLfloat zFar)
{
    NO_IMPL();
}

void GLES::GetClipPlanef(
    GLenum pname,
    GLfloat eqn[4])
{
    NO_IMPL();
}

void GLES::GetFloatv(
    GLenum pname,
    GLfloat *params)
{
    NO_IMPL();
}

void GLES::GetLightfv(
    GLenum light,
    GLenum pname,
    GLfloat *params)
{
    NO_IMPL();
}

void GLES::GetMaterialfv(
    GLenum face,
    GLenum pname,
    GLfloat *params)
{
    NO_IMPL();
}

void GLES::GetTexEnvfv(
    GLenum env,
    GLenum pname,
    GLfloat *params)
{
    NO_IMPL();
}

void GLES::GetTexParameterfv(
    GLenum target,
    GLenum pname,
    GLfloat *params)
{
    NO_IMPL();
}

void GLES::LightModelf(
    GLenum pname,
    GLfloat param)
{
    NO_IMPL();
}

void GLES::LightModelfv(
    GLenum pname,
    const GLfloat *params)
{
    NO_IMPL();
}

void GLES::Lightf(
    GLenum light,
    GLenum pname,
    GLfloat param)
{
    NO_IMPL();
}

void GLES::Lightfv(
    GLenum light,
    GLenum pname,
    const GLfloat *params)
{
    NO_IMPL();
}

void GLES::LineWidth(GLfloat width)
{
    NO_IMPL();
}

void GLES::LoadMatrixf(const GLfloat *m)
{
    NO_IMPL();
}

void GLES::Materialf(
    GLenum face,
    GLenum pname,
    GLfloat param)
{
    NO_IMPL();
}

void GLES::Materialfv(
    GLenum face,
    GLenum pname,
    const GLfloat *params)
{
    NO_IMPL();
}

void GLES::MultMatrixf(const GLfloat *m)
{
    NO_IMPL();
}

void GLES::MultiTexCoord4f(
    GLenum target,
    GLfloat s,
    GLfloat t,
    GLfloat r,
    GLfloat q)
{
    NO_IMPL();
}

void GLES::Normal3f(
    GLfloat nx,
    GLfloat ny,
    GLfloat nz)
{
    NO_IMPL();
}

void GLES::Orthof(
    GLfloat left,
    GLfloat right,
    GLfloat bottom,
    GLfloat top,
    GLfloat zNear,
    GLfloat zFar)
{
    NO_IMPL();
}

void GLES::PointParameterf(
    GLenum pname,
    GLfloat param)
{
    NO_IMPL();
}

void GLES::PointParameterfv(
    GLenum pname,
    const GLfloat *params)
{
    NO_IMPL();
}

void GLES::PointSize(GLfloat size)
{
    NO_IMPL();
}

void GLES::PolygonOffset(
    GLfloat factor,
    GLfloat units)
{
    NO_IMPL();
}

void GLES::Rotatef(
    GLfloat angle,
    GLfloat x,
    GLfloat y,
    GLfloat z)
{
    NO_IMPL();
}

void GLES::Scalef(
    GLfloat x,
    GLfloat y,
    GLfloat z)
{
    NO_IMPL();
}

void GLES::TexEnvf(
    GLenum target,
    GLenum pname,
    GLfloat param)
{
    NO_IMPL();
}

void GLES::TexEnvfv(
    GLenum target,
    GLenum pname,
    const GLfloat *params)
{
    NO_IMPL();
}

void GLES::TexParameterf(
    GLenum target,
    GLenum pname,
    GLfloat param)
{
    NO_IMPL();
}

void GLES::TexParameterfv(
    GLenum target,
    GLenum pname,
    const GLfloat *params)
{
    NO_IMPL();
}

void GLES::Translatef(
    GLfloat x,
    GLfloat y,
    GLfloat z)
{
    NO_IMPL();
}

void GLES::ActiveTexture(GLenum texture)
{
    NO_IMPL();
}

void GLES::BindBuffer(
    GLenum target,
    GLuint buffer)
{
    NO_IMPL();
}

void GLES::BindTexture(
    GLenum target,
    GLuint texture)
{
    NO_IMPL();
}

void GLES::BlendFunc(
    GLenum sfactor,
    GLenum dfactor)
{
    NO_IMPL();
}

void GLES::BufferData(
    GLenum target,
    GLsizeiptr size,
    const GLvoid *data,
    GLenum usage)
{
    NO_IMPL();
}

void GLES::BufferSubData(
    GLenum target,
    GLintptr offset,
    GLsizeiptr size,
    const GLvoid *data)
{
    NO_IMPL();
}

void GLES::Clear(GLbitfield mask)
{
    NO_IMPL();
}

void GLES::ClearStencil(GLint s)
{
    NO_IMPL();
}

void GLES::ClientActiveTexture(GLenum texture)
{
    NO_IMPL();
}

void GLES::Color4ub(
    GLubyte red,
    GLubyte green,
    GLubyte blue,
    GLubyte alpha)
{
    NO_IMPL();
}

void GLES::ColorMask(
    GLboolean red,
    GLboolean green,
    GLboolean blue,
    GLboolean alpha)
{
    NO_IMPL();
}

void GLES::ColorPointer(
    GLint size,
    GLenum type,
    GLsizei stride,
    const GLvoid *pointer)
{
    NO_IMPL();
}

void GLES::CompressedTexImage2D(
    GLenum target,
    GLint level,
    GLenum internalformat,
    GLsizei width,
    GLsizei height,
    GLint border,
    GLsizei imageSize,
    const GLvoid *data)
{
    NO_IMPL();
}

void GLES::CompressedTexSubImage2D(
    GLenum target,
    GLint level,
    GLint xoffset,
    GLint yoffset,
    GLsizei width,
    GLsizei height,
    GLenum format,
    GLsizei imageSize,
    const GLvoid *data)
{
    NO_IMPL();
}

void GLES::CopyTexImage2D(
    GLenum target,
    GLint level,
    GLenum internalformat,
    GLint x,
    GLint y,
    GLsizei width,
    GLsizei height,
    GLint border)
{
    NO_IMPL();
}

void GLES::CopyTexSubImage2D(
    GLenum target,
    GLint level,
    GLint xoffset,
    GLint yoffset,
    GLint x,
    GLint y,
    GLsizei width,
    GLsizei height)
{
    NO_IMPL();
}

void GLES::CullFace(GLenum mode)
{
    NO_IMPL();
}

void GLES::DeleteBuffers(
    GLsizei n,
    const GLuint *buffers)
{
    NO_IMPL();
}

void GLES::DeleteTextures(
    GLsizei n,
    const GLuint *textures)
{
    NO_IMPL();
}

void GLES::DepthFunc(GLenum func)
{
    NO_IMPL();
}

void GLES::DepthMask(GLboolean flag)
{
    NO_IMPL();
}

void GLES::Disable(GLenum cap)
{
    NO_IMPL();
}

void GLES::DisableClientState(GLenum array)
{
    NO_IMPL();
}

void GLES::DrawArrays(GLenum mode, GLint first, GLsizei count)
{
    NO_IMPL();
}

void GLES::DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid *indices)
{
    NO_IMPL();
}

void GLES::Enable(GLenum cap)
{
    NO_IMPL();
}

void GLES::EnableClientState(GLenum array)
{
    NO_IMPL();
}

void GLES::Finish(void)
{
    NO_IMPL();
}

void GLES::Flush(void)
{
    NO_IMPL();
}

void GLES::FrontFace(GLenum mode)
{
    NO_IMPL();
}

void GLES::GetBooleanv(GLenum pname, GLboolean *params)
{
    NO_IMPL();
}

void GLES::GetBufferParameteriv(GLenum target, GLenum pname, GLint *params)
{
    NO_IMPL();
}

void GLES::GenBuffers(GLsizei n, GLuint *buffers)
{
    NO_IMPL();
}

void GLES::GenTextures(GLsizei n, GLuint *textures)
{
    NO_IMPL();
}

GLenum GLES::GetError(void)
{
    NO_IMPL();
    return GL_INVALID_OPERATION;
}

void GLES::GetIntegerv(GLenum pname, GLint *params)
{
    NO_IMPL();
}

void GLES::GetPointerv(GLenum pname, GLvoid **params)
{
    NO_IMPL();
}

const GLubyte * GLES::GetString(GLenum name)
{
    NO_IMPL();
    return 0;
}

void GLES::GetTexEnviv(GLenum env, GLenum pname, GLint *params)
{
    NO_IMPL();
}

void GLES::GetTexParameteriv(GLenum target, GLenum pname, GLint *params)
{
    NO_IMPL();
}

void GLES::Hint(GLenum target, GLenum mode)
{
    NO_IMPL();
}

GLboolean GLES::IsBuffer(GLuint buffer)
{
    NO_IMPL();
    return GL_FALSE;
}

GLboolean GLES::IsEnabled(GLenum cap)
{
    NO_IMPL();
    return GL_FALSE;
}

GLboolean GLES::IsTexture(GLuint texture)
{
    NO_IMPL();
    return GL_FALSE;
}

void GLES::LoadIdentity(void)
{
    NO_IMPL();
}

void GLES::LogicOp(GLenum opcode)
{
    NO_IMPL();
}

void GLES::MatrixMode(GLenum mode)
{
    NO_IMPL();
}

void GLES::NormalPointer(GLenum type, GLsizei stride, const GLvoid *pointer)
{
    NO_IMPL();
}

void GLES::PixelStorei(GLenum pname, GLint param)
{
    NO_IMPL();
}

void GLES::PopMatrix(void)
{
    NO_IMPL();
}

void GLES::PushMatrix(void)
{
    NO_IMPL();
}

void GLES::ReadPixels(
    GLint x,
    GLint y,
    GLsizei width,
    GLsizei height,
    GLenum format,
    GLenum type,
    GLvoid *pixels)
{
    NO_IMPL();
}

void GLES::SampleCoverage(GLclampf value, GLboolean invert)
{
    NO_IMPL();
}

void GLES::Scissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
    NO_IMPL();
}

void GLES::ShadeModel(GLenum mode)
{
    NO_IMPL();
}

void GLES::StencilFunc(GLenum func, GLint ref, GLuint mask)
{
    NO_IMPL();
}

void GLES::StencilMask(GLuint mask)
{
    NO_IMPL();
}

void GLES::StencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
    NO_IMPL();
}

void GLES::TexCoordPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    NO_IMPL();
}

void GLES::TexEnvi(GLenum target, GLenum pname, GLint param)
{
    NO_IMPL();
}

void GLES::TexEnviv(GLenum target, GLenum pname, const GLint *params)
{
    NO_IMPL();
}

void GLES::TexImage2D(
    GLenum target,
    GLint level,
    GLint internalformat,
    GLsizei width,
    GLsizei height,
    GLint border,
    GLenum format,
    GLenum type,
    const GLvoid *pixels)
{
    NO_IMPL();
}

void GLES::TexParameteri(GLenum target, GLenum pname, GLint param)
{
    NO_IMPL();
}

void GLES::TexParameteriv(GLenum target, GLenum pname, const GLint *params)
{
    NO_IMPL();
}

void GLES::TexSubImage2D(
    GLenum target,
    GLint level,
    GLint xoffset,
    GLint yoffset,
    GLsizei width,
    GLsizei height,
    GLenum format,
    GLenum type,
    const GLvoid *pixels)
{
    NO_IMPL();
}

void GLES::VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *pointer)
{
    NO_IMPL();
}

void GLES::Viewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
    NO_IMPL();
}



/*********************************************************/
/* Fixed API                                             */
/*********************************************************/

void GLES::AlphaFuncx(
    GLenum func,
    GLclampx ref)
{
    NO_IMPL();
}

void GLES::ClearColorx(
    GLclampx red,
    GLclampx green,
    GLclampx blue,
    GLclampx alpha)
{
    NO_IMPL();
}

void GLES::ClearDepthx(GLclampx depth)
{
    NO_IMPL();
}

void GLES::ClipPlanex(
    GLenum plane,
    const GLfixed *equation)
{
    NO_IMPL();
}

void GLES::Color4x(
    GLfixed red,
    GLfixed green,
    GLfixed blue,
    GLfixed alpha)
{
    NO_IMPL();
}

void GLES::DepthRangex(GLclampx zNear, GLclampx zFar)
{
    NO_IMPL();
}

void GLES::Fogx(GLenum pname, GLfixed param)
{
    NO_IMPL();
}

void GLES::Fogxv(GLenum pname, const GLfixed *params)
{
    NO_IMPL();
}

void GLES::Frustumx(
    GLfixed left,
    GLfixed right,
    GLfixed bottom,
    GLfixed top,
    GLfixed zNear,
    GLfixed zFar)
{
    NO_IMPL();
}

void GLES::GetClipPlanex(GLenum pname, GLfixed eqn[4])
{
    NO_IMPL();
}

void GLES::GetFixedv(GLenum pname, GLfixed *params)
{
    NO_IMPL();
}

void GLES::GetLightxv(GLenum light, GLenum pname, GLfixed *params)
{
    NO_IMPL();
}

void GLES::GetMaterialxv(GLenum face, GLenum pname, GLfixed *params)
{
    NO_IMPL();
}

void GLES::GetTexEnvxv(GLenum env, GLenum pname, GLfixed *params)
{
    NO_IMPL();
}

void GLES::GetTexParameterxv(GLenum target, GLenum pname, GLfixed *params)
{
    NO_IMPL();
}

void GLES::LightModelx(GLenum pname, GLfixed param)
{
    NO_IMPL();
}

void GLES::LightModelxv(GLenum pname, const GLfixed *params)
{
    NO_IMPL();
}

void GLES::Lightx(GLenum light, GLenum pname, GLfixed param)
{
    NO_IMPL();
}

void GLES::Lightxv(GLenum light, GLenum pname, const GLfixed *params)
{
    NO_IMPL();
}

void GLES::LineWidthx(GLfixed width)
{
    NO_IMPL();
}

void GLES::LoadMatrixx(const GLfixed *m)
{
    NO_IMPL();
}

void GLES::Materialx(GLenum face, GLenum pname, GLfixed param)
{
    NO_IMPL();
}

void GLES::Materialxv(GLenum face, GLenum pname, const GLfixed *params)
{
    NO_IMPL();
}

void GLES::MultMatrixx(const GLfixed *m)
{
    NO_IMPL();
}

void GLES::MultiTexCoord4x(GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q)
{
    NO_IMPL();
}

void GLES::Normal3x(GLfixed nx, GLfixed ny, GLfixed nz)
{
    NO_IMPL();
}

void GLES::Orthox(
    GLfixed left,
    GLfixed right,
    GLfixed bottom,
    GLfixed top,
    GLfixed zNear,
    GLfixed zFar)
{
    NO_IMPL();
}

void GLES::PointParameterx(GLenum pname, GLfixed param)
{
    NO_IMPL();
}

void GLES::PointParameterxv(GLenum pname, const GLfixed *params)
{
    NO_IMPL();
}

void GLES::PointSizex(GLfixed size)
{
    NO_IMPL();
}

void GLES::PolygonOffsetx(GLfixed factor, GLfixed units)
{
    NO_IMPL();
}

void GLES::Rotatex(GLfixed angle, GLfixed x, GLfixed y, GLfixed z)
{
    NO_IMPL();
}

void GLES::SampleCoveragex(GLclampx value, GLboolean invert)
{
    NO_IMPL();
}

void GLES::Scalex(GLfixed x, GLfixed y, GLfixed z)
{
    NO_IMPL();
}

void GLES::TexEnvx(GLenum target, GLenum pname, GLfixed param)
{
    NO_IMPL();
}

void GLES::TexEnvxv(GLenum target, GLenum pname, const GLfixed *params)
{
    NO_IMPL();
}

void GLES::TexParameterx(GLenum target, GLenum pname, GLfixed param)
{
    NO_IMPL();
}

void GLES::TexParameterxv(GLenum target, GLenum pname, const GLfixed *params)
{
    NO_IMPL();
}

void GLES::Translatex(GLfixed x, GLfixed y, GLfixed z)
{
    NO_IMPL();
}

}
